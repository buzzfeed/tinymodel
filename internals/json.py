import json as j

def __field_from_json(tinymodel, allowed_types, json_value, this_field_def=None):
    """
    Generates an instance of a specified type, with a value specified by a passed-in JSON object.
    Since the model has already passed validation, we can assume that allowed_types are either one of the SUPPORTED_BUILTINS or a valid user-defined type.
    Be aware that this assumption may not hold true if the field was set to validate=False

    :param [class | {class: class} | [class] | (class,) | {class,}] allowed_types: The allowed types of the object to generate, as an array of Python class definitions
    :param str | int | dict | list | bool | None json_value: Either a JSON-formatted string containing the value of the object we are generating,
                                                             or the value itself as an int, dict, list, bool or NoneType.
    :param FieldDef this_field_def: The field that we are generating a random value for

    :rtype object: An instance of this_type, with value specified by json_value

    """

    type_of_value = type(json_value)
    if this_field_def.relationship == "has_one":
        allowed_types += [long, int, unicode, str]
    elif this_field_def.relationship == "has_many":
        allowed_types += [[long], [int], [unicode], [str]]

    if type_of_value == dict:
        # Use first allowed dict type or user-defined type
        first_usable_type = next(iter([allowed_type for allowed_type in allowed_types if (type(allowed_type) == dict or allowed_type not in tinymodel.SUPPORTED_BUILTINS)]), None)
        if type(first_usable_type) == dict:
            (key_type, value_type) = first_usable_type.items()[0]
            return tinymodel.SUPPORTED_BUILTINS[dict]['from_json'](key_type, value_type, json_value, this_field_def)
        elif first_usable_type:
            # Assume we are dealing with a valid user-defined type
            return first_usable_type().from_json(model_as_json=json_value, preprocessed=True)
        else:
            tinymodel.JSON_FAILURES.append("from_json translation error in " + this_field_def.title + " field: JSON 'object' type not supported by FieldDef.allowed_types")
            return None
    elif type_of_value in tinymodel.COLLECTION_TYPES:
        # Use first allowed iterable type
        first_usable_type = next(iter([allowed_type for allowed_type in allowed_types if (type(allowed_type) in (list, tuple, set))]), None)
        if first_usable_type:
            element_type = iter(first_usable_type).next()
            return tinymodel.SUPPORTED_BUILTINS[type(first_usable_type)]['from_json'](element_type, json_value, this_field_def)
        else:
            tinymodel.JSON_FAILURES.append("from_json translation error in " + this_field_def.title + " field: JSON 'array' type not supported by FieldDef.allowed_types")
            return None
    elif type_of_value == unicode:
        # Use first allowed non-collection type
        first_usable_type = next(iter(filter(lambda t: (t in set(tinymodel.SUPPORTED_BUILTINS) - set(tinymodel.COLLECTION_TYPES)) or issubclass(t, TinyModel), allowed_types)), None)
        if first_usable_type:
            if issubclass(first_usable_type, TinyModel):
                try:
                    return first_usable_type().from_json(json_value, do_validation=False)
                except ValueError:
                    tinymodel.JSON_FAILURES.append("from_json translation error in " + this_field_def.title + " field: JSON 'string | number | true | false | null' type not supported by ModelField.allowed_types")
                    return None
            json_value = '"' + json_value + '"'
            return tinymodel.SUPPORTED_BUILTINS[first_usable_type]['from_json'](json_value)
        else:
            tinymodel.JSON_FAILURES.append("from_json translation error in " + this_field_def.title + " field: JSON 'string | number | true | false | null' type not supported by FieldDef.allowed_types")
            return None
    else:
        # No further translation necessary, but did we translate to an allowed type?
        if type_of_value in allowed_types:
            return json_value
        else:
            # Did not translate to an allowed type. Cast it back to JSON, find the allowed type, and translate to that.
            first_usable_type = next(iter([allowed_type for allowed_type in allowed_types]))
            return tinymodel.SUPPORTED_BUILTINS[first_usable_type]['from_json'](j.dumps(json_value))

def __field_to_json(tinymodel, this_value):
    """
    Generates JSON-formatted string representation of a field value. Nested collection types are generated by recursion.
    Since the model has already passed validation, we can assume that type(this_value) is either one of the SUPPORTED_BUILTINS or a valid user-defined type.
    Be aware that this assumption may not hold true if the field was set to validate=False

    :param object this_value: The current value of the field as a Python object.

    :rtype str: A JSON-formatted string representation of the field value

    """

    type_of_value = type(this_value)

    if type_of_value in tinymodel.SUPPORTED_BUILTINS:
        return tinymodel.SUPPORTED_BUILTINS[type_of_value]['to_json'](this_value)
    else:
        # Assume we are dealing with a valid user-defined type
        return this_value.to_json()


def from_json(tinymodel, model_as_json, preprocessed=False, do_validation=True, warning_only=True):
    """
    Creates an object from its JSON representation
    Simultaneously iterates over the FIELD_DEFS attribute and the passed-in JSON representation
    to translate each JSON field value into its corresponding Python FIELD_DEFS type.

    We also assume that model_as_json is formatted as a JSON dict,
    and that the keys of this dict exactly match the keys of the FIELD_DEFS attribute

    Please note that JSON supports ONLY STRINGS AS DICT KEYS!
    Dict-type fields with key types other than str are not guaranteed to work with this method.

    If multiple allowed_types are specified for a field, then the first usable type is the one used for JSON translation.

    :param str model_as_json: A representation of the model in JSON format
    :param bool preprocessed: A flag indicating whether model_as_json has already been through a JSON preprocessor
    :param bool do_validation: A flag indicating whether the resulting model should be validated before returning
    :param bool warning_only: If True, any validation errors produce only warnings instead of Exceptions.

    :rtype dict: A dict of keys and values for the fields to set.

    """
    tinymodel.JSON_FAILURES = []
    json_fields = {}
    fields_to_set = {}

    if not preprocessed:
        # Assume that the base JSON object is formatted as a dict.
        json_fields = j.loads(model_as_json)
    else:
        json_fields = model_as_json

    for (json_field_name, json_field_value) in json_fields.items():
        this_field_def = next((f for f in tinymodel.FIELD_DEFS if json_field_name in [f.title, f.title + "_id", f.title + "_ids"]), None)
        if this_field_def:
            fields_to_set[json_field_name] = tinymodel.__field_from_json(allowed_types=this_field_def.allowed_types, json_value=json_field_value,
                                                                    this_field_def=this_field_def)
    return fields_to_set


def to_json(tinymodel, do_validation=True, warning_only=True, return_dict=False):
    """
    Creates a JSON representation of a model
    Iterates over the FIELD_DEFS attribute to translate each field value into its corresponding JSON representation.

    Please note that JSON supports ONLY STRINGS AS DICT KEYS!
    Dict-type fields with key types other than str are not guaranteed to work with this method.

    :param bool do_validation: A flag indicating whether the resulting model should be validated before returning
    :param bool warning_only: If True, any validation errors produce only warnings instead of Exceptions.

    :rtype str: A JSON-formatted str representation of this model

    """
    json_fields = {}
    object_as_json = ''
    if do_validation:
        tinymodel.validate(warning_only=warning_only)
    for field in tinymodel.FIELDS:
        try:
            json_fields.update({field.title: tinymodel.__field_to_json(this_value=getattr(tinymodel, field.title))})
        except AttributeError:
            pass
    object_as_json = '{' + ','.join([('"' + key + '": ' + value) for (key, value) in json_fields.items()]) + '}'

    try:
        object_as_dict = j.loads(object_as_json)
    except:
        if warning_only:
            warnings.warn(str(tinymodel) + " could not be translated to a valid JSON object")
        else:
            raise Exception(str(tinymodel) + " could not be translated to a valid JSON object")
    else:
        if return_dict:
            return object_as_dict
        else:
            return object_as_json
